<#+

void Print_Equatable()
{
#>
    public static void IsNull<T>(in T? actual) where T: struct
    {
      Assert.True(actual is null, $"actual is not null\n");
    }
    
    public static void IsNull<T>(in T? actual) where T: class
    {
      Assert.True(actual is null, $"actual is not null\n");
    }

    //
    // AreEqual
    //

    public static void AreEqual<T>(in T expected, in T actual) where T: IEquatable<T>, IValueObject
    {      
      Type tType = typeof(T);
      if (tType == typeof(double) || tType == typeof(string))
      {
        throw new InvalidOperationException("Something went wrong.");
      }

      Assert.True(expected.Equals(actual), $"{expected.ToString()}\n\nis not equal to\n\n{actual.ToString()}\n");
    }

    public static void AreEqual(in double expected, in double actual)
    {
      AreEqual<Number>(expected, actual);
    }

    public static void AreEqual(in string expected, in string actual)
    {
      Assert.Equal(expected, actual);
    }    

    public static void AreEqual(in int expected, in int actual)
    {
      Assert.True(expected == actual, $"{expected.ToString()}\n\nis not equal to\n\n{actual.ToString()}\n");
    }

    public static void AreEqual(in uint expected, in uint actual)
    {
      Assert.True(expected == actual, $"{expected.ToString()}\n\nis not equal to\n\n{actual.ToString()}\n");
    }

    public static void AreEqual(in ulong expected, in ulong actual)
    {
      Assert.True(expected == actual, $"{expected.ToString()}\n\nis not equal to\n\n{actual.ToString()}\n");
    }

    public static void AreEqual(in long expected, in long actual)
    {
      Assert.True(expected == actual, $"{expected.ToString()}\n\nis not equal to\n\n{actual.ToString()}\n");
    }

    //
    // AreNotEqual
    //

    public static void AreNotEqual<T>(in T expected, in T actual) where T: IEquatable<T>, IValueObject
    {
      Type tType = typeof(T);
      if (tType == typeof(double) || tType == typeof(string))
      {
        throw new InvalidOperationException("Something went wrong.");
      }
      
      Assert.False(expected.Equals(actual), $"{expected.ToString()}\n\nis equal to\n\n{actual.ToString()}\n");      
    }

    public static void AreNotEqual(in double expected, in double actual)
    {
      AreNotEqual<Number>(expected, actual);
    }

    public static void AreNotEqual(in string expected, in string actual)
    {
      Assert.NotEqual(expected, actual);
    }        

    public static void AreNotEqual(in uint expected, in uint actual)
    {
      Assert.True(expected != actual, $"{expected.ToString()}\n\nis equal to\n\n{actual.ToString()}\n");
    }

    public static void AreNotEqual(in int expected, in int actual)
    {
      Assert.True(expected != actual, $"{expected.ToString()}\n\nis equal to\n\n{actual.ToString()}\n");
    }

    public static void AreNotEqual(in ulong expected, in ulong actual)
    {
      Assert.True(expected != actual, $"{expected.ToString()}\n\nis equal to\n\n{actual.ToString()}\n");
    }

    public static void AreNotEqual(in long expected, in long actual)
    {
      Assert.True(expected != actual, $"{expected.ToString()}\n\nis equal to\n\n{actual.ToString()}\n");
    }

    //
    // AreEquals
    //

    public static void AreEquals(in IEnumerable<int> expected, in IEnumerable<int> actual)
    {
      var expectedArray = expected.ToReadOnlyList();
      var actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEqual(expectedArray[i], actualArray[i]);
      }
    }

    public static void AreEquals(in IEnumerable<uint> expected, in IEnumerable<uint> actual)
    {
      var expectedArray = expected.ToReadOnlyList();
      var actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEqual(expectedArray[i], actualArray[i]);
      }
    }

    public static void AreEquals(in IEnumerable<IEnumerable<int>> expected, in IEnumerable<IEnumerable<int>> actual)
    {
      var expectedArray = expected.ToReadOnlyList();
      var actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEquals(expectedArray[i], actualArray[i]);
      }
    }

    public static void AreEquals<T>(in IEnumerable<T> expected, in IEnumerable<T> actual)  where T: IEquatable<T>, IValueObject
    {
      IReadOnlyList<T> expectedArray = expected.ToReadOnlyList();
      IReadOnlyList<T> actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEqual(expectedArray[i], actualArray[i]);
      }
    }

    public static void AreEquals<T>(in IEnumerable<IEnumerable<T>> expected, in IEnumerable<IEnumerable<T>> actual) where T : IEquatable<T>, IValueObject
    {
      IReadOnlyList<IEnumerable<T>> expectedArray = expected.ToReadOnlyList();
      IReadOnlyList<IEnumerable<T>> actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEquals(expectedArray[i], actualArray[i]);
      }
    }

<#+
    foreach(string typeName in new[] { "double", "string"})
    {
#>
    public static void AreEquals(in IEnumerable<<#= typeName #>> expected, in IEnumerable<<#= typeName #>> actual)
    {
      IReadOnlyList<<#= typeName #>> expectedArray = expected.ToReadOnlyList();
      IReadOnlyList<<#= typeName #>> actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEqual(expectedArray[i], actualArray[i]);
      }
    }

    public static void AreEquals(in IEnumerable<IEnumerable<<#= typeName #>>> expected, in IEnumerable<IEnumerable<<#= typeName #>>> actual)
    {
      IReadOnlyList<IEnumerable<<#= typeName #>>> expectedArray = expected.ToReadOnlyList();
      IReadOnlyList<IEnumerable<<#= typeName #>>> actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreEquals(expectedArray[i], actualArray[i]);
      }
    }

<#+
    }
}

void Print_AreExactlyEqual()
{
#>
    //
    // AreExactlyEqual
    //

    public static void AreExactlyEqual(in double expected, in double actual)
    {
      // ReSharper disable once CompareOfFloatsByEqualityOperator
      Assert.True(expected == actual, $"{expected.ToString(CultureInfo.CurrentCulture)} is not equal to {actual.ToString(CultureInfo.CurrentCulture)}\n");
    }

    public static void AreExactlyEqual(in Number expected, in Number actual)
    {
      AreExactlyEqual((double)expected, (double)actual);
    }

    public static void AreExactlyNotEqual(in double expected, in double actual)
    {
      // ReSharper disable once CompareOfFloatsByEqualityOperator
      Assert.False(expected == actual, $"{expected.ToString(CultureInfo.CurrentCulture)} is equal to {actual.ToString(CultureInfo.CurrentCulture)}\n");
    }    

    public static void AreExactlyNotEqual(in Number expected, in Number actual)
    {
      AreExactlyNotEqual((double)expected, (double)actual);
    }

    public static void IsExactlyZero(in double actual)
    {
      // ReSharper disable once CompareOfFloatsByEqualityOperator
      Assert.True(0 == actual, $"{actual.ToString(CultureInfo.CurrentCulture)} is not zero");
    }

    public static void IsExactlyZero(in Number actual)
    {
      IsExactlyZero((double)actual);
    }

    public static void AreExactlyEquals(in IEnumerable<double> expected, in IEnumerable<double> actual)
    {
      IReadOnlyList<double> expectedArray = expected.ToReadOnlyList();
      IReadOnlyList<double> actualArray = actual.ToReadOnlyList();
      AreEqual(expectedArray.Count, actualArray.Count);
      for (int i = 0; i < expectedArray.Count; i++)
      {
        AreExactlyEqual(expectedArray[i], actualArray[i]);
      }
    }

<#+
}

void Print_IsZero(string typeName)
{    
#>   
    //
    // IsZero
    //

    public static void IsZero(in <#= typeName #> value)
    {
      AreEqual(0, in value);
    }

    public static void IsNotZero(in <#= typeName #> value)
    {
      AreNotEqual(0, in value);
    }

<#+    
}

void Print_NumberExtensionCommon()
{    
#>   
    //
    // Number extensions
    //

    public static void IsZero(in Number value)
    {
      AreEqual<Number>(0d, value);
    }

    public static void IsNotZero(in Number value)
    {
      AreNotEqual<Number>(0d, in value);
    }

<#+    
}

void Print_NumberExtension(string typeName)
{    
#>   
    //
    // <#= typeName #> to Number
    //

    public static void AreEqual(in <#= typeName #> expected, in Number? actual)
    {
      Assert.False(actual is null, "actual is null");
      Number expectedNumber = expected;
      AreEqual(in expectedNumber, actual ?? throw new InvalidOperationException("Actual is null"));
    }    

    public static void AreEqual(in <#= typeName #> expected, in Number actual)
    {
      Number expectedNumber = expected;
      AreEqual(in expectedNumber, actual);
    }    

    public static void AreNotEqual(in <#= typeName #> expected, in Number actual)
    {
      Number expectedNumber = expected;
      AreNotEqual(in expectedNumber, in actual);            
    }

    public static void AreEquals(in IEnumerable<<#= typeName #>> expected, in IEnumerable<Number> actual)
    {
      AreEquals(expected.Select(v => (Number)v), in actual);
    }

<#+    
}

void Print_Comparision(string typeName, bool canBeNegative)
{    
#>   
    //
    // comparision operators for <#= typeName #>
    //

    public static void IsBetween(in <#= typeName #> lower, <#= typeName #> high, in <#= typeName #> value)
    {
      Assert.True(lower <= value  && value <= high, $"{value.ToString()} is not between {lower.ToString()} and {high.ToString()}");
    }

    public static void IsGreaterThan(in <#= typeName #> baseline, in <#= typeName #> value)
    {
      Assert.True(value > baseline, $"{value.ToString()} is not greater than {baseline.ToString()}");
    }

    public static void IsGreaterEqualThan(in <#= typeName #> baseline, in <#= typeName #> value)
    {
      Assert.True(value >= baseline, $"{value.ToString()} is not greater or equal than {baseline.ToString()}");
    }

    public static void IsLowerThan(in <#= typeName #> baseline, in <#= typeName #> value)
    {
      Assert.True(value < baseline, $"{value.ToString()} is not lower than {baseline.ToString()}");
    }

    public static void IsLowerEqualThan(in <#= typeName #> baseline, in <#= typeName #> value)
    {
      Assert.True(value <= baseline, $"{value.ToString()} is not lower or equal than {baseline.ToString()}");
    }    

    public static void IsPositive(in <#= typeName #> value)
    {
      Assert.True(value > 0, $"{value.ToString()} is not positive");
    }    

<#+
    if (canBeNegative)
    {
#> 
    public static void IsNegative(in <#= typeName #> value)
    {
      Assert.True(value < 0, $"{value.ToString()} is not negative");
    }
<#+     
    }
}

void Print_Logical()
{
#>
    //
    // Logical
    //

    public static void IsTrue(in bool value)
    {
      Assert.True(value);
    }

    public static void IsFalse(in bool value)
    {
      Assert.False(value);
    }

<#+
}

void Print_Enumerable()
{
#>
    //
    // Enumerable
    //

    public static void IsEmpty<T>(in IEnumerable<T> value)
    {
      AreEqual(0, value.Count());
    }

<#+
}

void Print_ExpectedErrors()
{
#>
    //
    // Expected errors
    //

    public static void Throws<T>(in Action testCode) where T : Exception
    {
      Assert.Throws<T>(testCode);
    }

    public static void Throws<T>(in Func<object> testCode) where T : Exception
    {
      Assert.Throws<T>(testCode);
    }

<#+
}



void PrintCommon()
{   
    Print_Equatable();    
    foreach(string typeName in new[] {"int", "uint", "long", "ulong"})
    {
        Print_Comparision(typeName, canBeNegative: !typeName.StartsWith("u"));
        Print_IsZero(typeName);
    }
    Print_AreExactlyEqual();
    Print_NumberExtensionCommon();

    Print_Logical(); 
    Print_Enumerable();
    Print_ExpectedErrors();
}

#>