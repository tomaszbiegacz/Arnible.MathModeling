<#+

void Print_MinDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds minimum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MinDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v < result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMinimum(string typeName)
{
#>
    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMinimum<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }
      T? result = null;
      <#= typeName #> resultMinimum = default;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value < resultMinimum)
          {
            result = v;
            resultMinimum = value;
          }
        }
        else
        {
          result = v;
          resultMinimum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMinimumAt(string typeName)
{
#>
    /// <summary>
    /// Finds position of record with minimum value
    /// </summary>
    public static uint WithMinimumAt<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      uint? resultMinimumAt = null;
      <#= typeName #> resultMinimum = default;
      uint i = 0;
      foreach (T v in x)
      {
        if (resultMinimumAt.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value < resultMinimum)
          {
            resultMinimum = value;
            resultMinimumAt = i;
          }
        }
        else
        {
          resultMinimum = func(v);
          resultMinimumAt = i;
        }
        i++;
      }
      if (!resultMinimumAt.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return resultMinimumAt.Value;
    }

<#+
}

void Print_MaxDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds maximum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MaxDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v > result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMaximum(string typeName)
{
#>
    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMaximum<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }
      T? result = null;
      <#= typeName #> resultMaximum = default;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value > resultMaximum)
          {
            result = v;
            resultMaximum = value;
          }
        }
        else
        {
          result = v;
          resultMaximum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMaximumAt(string typeName)
{
#>
    /// <summary>
    /// Finds position of record with maximum value
    /// </summary>
    public static uint WithMaximumAt<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      uint? resultMaximumAt = null;
      <#= typeName #> resultMaximum = default;
      uint i = 0;
      foreach (T v in x)
      {
        if (resultMaximumAt.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value > resultMaximum)
          {
            resultMaximum = value;
            resultMaximumAt = i;
          }
        }
        else
        {
          resultMaximum = func(v);
          resultMaximumAt = i;
        }
        i++;
      }
      if (!resultMaximumAt.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return resultMaximumAt.Value;
    }

<#+
}

void Print_MedianDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds median value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MedianDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }

      <#= typeName #>[] items = x.ToArray();
      if(items.Length == 0)
      {
        throw new ArgumentNullException(nameof(x));
      }
      Array.Sort(items);
      return items[items.Length / 2];
    }

<#+
}

#>