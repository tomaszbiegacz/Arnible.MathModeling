<#+

void Print_MinOrDefault(string typeName)
{
#>
    /// <summary>
    /// Finds minimum value for not null values or return null
    /// </summary>
    public static <#= typeName #>? MinOrDefault(this IEnumerable<<#= typeName #>?> x)
    {      
      <#= typeName #>? result = null;
      foreach (<#= typeName #>? v in x)
      {
        if(v.HasValue)
        {
            if (result.HasValue)
            {
              if (v < result.Value)
              {
                result = v;
              }
            }
            else
            {
              result = v;
            }
        }                
      }
      return result;
    }

<#+
}

void Print_MinDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds minimum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MinDefensive(this IEnumerable<<#= typeName #>> x)
    {      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v < result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMinimum(string typeName)
{
#>
    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMinimum<T>(this IEnumerable<T> x, in Func<T, <#= typeName #>> func) where T : struct
    {      
      T? result = null;
      <#= typeName #> resultMinimum = default;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value < resultMinimum)
          {
            result = v;
            resultMinimum = value;
          }
        }
        else
        {
          result = v;
          resultMinimum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMinimumAt(string typeName)
{
#>
    /// <summary>
    /// Finds position of record with minimum value
    /// </summary>
    public static uint WithMinimumAt<T>(this IEnumerable<T> x, in Func<T, <#= typeName #>> func) where T : struct
    {      
      uint? resultMinimumAt = null;
      <#= typeName #> resultMinimum = default;
      uint i = 0;
      foreach (T v in x)
      {
        if (resultMinimumAt.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value < resultMinimum)
          {
            resultMinimum = value;
            resultMinimumAt = i;
          }
        }
        else
        {
          resultMinimum = func(v);
          resultMinimumAt = i;
        }
        i++;
      }
      if (!resultMinimumAt.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return resultMinimumAt.Value;
    }

<#+
}

void Print_MaxDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds maximum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MaxDefensive(this IEnumerable<<#= typeName #>> x)
    {      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v > result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMaximum(string typeName)
{
#>
    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMaximum<T>(this IEnumerable<T> x, in Func<T, <#= typeName #>> func) where T : struct
    {      
      T? result = null;
      <#= typeName #> resultMaximum = default;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value > resultMaximum)
          {
            result = v;
            resultMaximum = value;
          }
        }
        else
        {
          result = v;
          resultMaximum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

<#+
}

void Print_WithMaximumAt(string typeName)
{
#>
    /// <summary>
    /// Finds position of record with maximum value
    /// </summary>
    public static uint WithMaximumAt<T>(this IEnumerable<T> x, in Func<T, <#= typeName #>> func) where T : struct
    {      
      uint? resultMaximumAt = null;
      <#= typeName #> resultMaximum = default;
      uint i = 0;
      foreach (T v in x)
      {
        if (resultMaximumAt.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value > resultMaximum)
          {
            resultMaximum = value;
            resultMaximumAt = i;
          }
        }
        else
        {
          resultMaximum = func(v);
          resultMaximumAt = i;
        }
        i++;
      }
      if (!resultMaximumAt.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return resultMaximumAt.Value;
    }

<#+
}

void Print_MedianDefensive(string typeName)
{
#>
    /// <summary>
    /// Finds median value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MedianDefensive(this IEnumerable<<#= typeName #>> x)
    {
      List<<#= typeName #>> items = x.ToList();
      if(items.Count == 0)
      {
        throw new ArgumentException(nameof(x));
      }
      items.Sort();
      return items[items.Count / 2];
    }

<#+
}

#>