<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".tt.cs" #>
<#

//
// When changing anything here, change also LinqAggregateBasicNumber
//

string[] generatedTypes = new[] { "double", "int", "uint", "long", "ulong", "byte", "sbyte" };

#>
using System;
using System.Collections.Generic;

namespace Arnible.MathModeling
{
  public static class LinqAggregateBasic
  {
<#

foreach(string typeName in generatedTypes)
{

#>
    /// <summary>
    /// Finds minimum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MinDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v < result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMinimum<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }
      T? result = null;
      <#= typeName #> resultMinimum = 0;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value < resultMinimum)
          {
            result = v;
            resultMinimum = value;
          }
        }
        else
        {
          result = v;
          resultMinimum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }    

    /// <summary>
    /// Finds maximum value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MaxDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }      
      <#= typeName #>? result = null;
      foreach (<#= typeName #> v in x)
      {
        if (result.HasValue)
        {
          if (v > result.Value)
          {
            result = v;
          }
        }
        else
        {
          result = v;
        }        
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

    /// <summary>
    /// Finds record with minimum value
    /// </summary>
    public static T WithMaximum<T>(this IEnumerable<T> x, Func<T, <#= typeName #>> func) where T : struct
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }
      T? result = null;
      <#= typeName #> resultMaximum = 0;
      foreach (T v in x)
      {
        if (result.HasValue)
        {
          <#= typeName #> value = func(v);
          if (value > resultMaximum)
          {
            result = v;
            resultMaximum = value;
          }
        }
        else
        {
          result = v;
          resultMaximum = func(v);
        }
      }
      if (!result.HasValue)
      {
        throw new ArgumentException("Empty enumerator");
      }
      return result.Value;
    }

    /// <summary>
    /// Finds median value or throw ArgumentException if passed enumerable is empty
    /// </summary>
    public static <#= typeName #> MedianDefensive(this IEnumerable<<#= typeName #>> x)
    {
      if (x == null)
      {
        throw new ArgumentNullException(nameof(x));
      }

      <#= typeName #>[] items = x.ToArray();
      if(items.Length == 0)
      {
        throw new ArgumentNullException(nameof(x));
      }
      Array.Sort(items);
      return items[items.Length / 2];
    }

<#

}

#>
  }
}
